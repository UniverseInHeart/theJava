[TOC]



##  分布式事务

 分布式条件下，多个节点操作的整体事务一致性。

特别是在微服务场景下，业务A和业务B关联，事务A成功，事务B失败，由于跨系统， 就会导致不被感知。此时从整体来看，数据是不一致的。

### 如何实现分布式下的一致性 

典型情况下是两个思路： 

1、理想状态：直接想单机数据库事务一样，多个数据库自动通过某种`协调机制`，实现了跨数据库节点的一致性。

使用场景：要求严格的一致性，比如金融交易类业务。

使用策略：XA

 2、一般情况：可以容忍一段时间的数据不一致，最终通过超时终止，调度补偿等等 方式，实现数据的最终状态一致性。 

使用场景：准实时或非实时的处理，比如T+1的各类操作，或者电商类操作

使用策略：柔性事务



## XA分布式事务



### XA分布式事务协议 

基于第一个强一致的思路，就有了基于数据库本身支持的协议，XA分布式事务。

XA整体设计思路可以概括为，如何在现有事务模型上微调扩展，实现分布式事务。

> `应用程序`(Application Program ，简称 AP) : 用于定义事务边界(即定义事务的开始和结束)，并且在事务边界内对资源进行操作。 

> `资源管理器`(Resource Manager，简称 RM)：如数据库、文件系统等，并提供访问资源的方式 ，如MySQL

> `事务管理器`(Transaction Manager ，简称 TM)：负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚等。

![image-20201209233209830](/Users/xjf/IdeaProjects/theJava/mysql/gitee/pic/image-20201209233209830.png)





### XA接口

<img src="/Users/xjf/IdeaProjects/theJava/mysql/gitee/pic/image-20201209234650908.png" alt="image-20201209234650908" style="zoom:50%;" />

### 常用的XA接口

- xa_start ：负责开启或者恢复一个事务分支 
- xa_end： 负责取消当前线程与事务分支的关联，告诉MySQL当前sql执行完成
- xa_prepare：询问 RM 是否准备好提交事务分支 
- xa_commit：通知 RM 提交事务分支 
- xa_rollback： 通知 RM 回滚事务分支 
- xa_recover : 需要恢复的 XA 事务

一个正常的流程

```sql
xa start 'x1'
insert---
update---
xa end 'x1'
xa prepare 'x1'
xa commit 'x1'
```



MySQL 从5.0.3开始支持InnoDB引擎的 XA 分布式事务，MySQL Connector/J 从5.0.0版本开始支持XA。

```sql
show engines; //查询是否支持XA
```

在 DTP 模型中，MySQL 属于资源管理器(RM)。分布式事务中存在多个 RM，由事务管理器 TM 来统一进行协调。

![image-20201209235011924](/Users/xjf/IdeaProjects/theJava/mysql/gitee/pic/image-20201209235011924.png)

### XA事务状态

![image-20201212145910459](/Users/xjf/IdeaProjects/theJava/mysql/gitee/pic/image-20201212145910459.png)

### 完整的XA事务处理过程

![image-20201212150008837](/Users/xjf/IdeaProjects/theJava/mysql/gitee/pic/image-20201212150008837.png)

### 单个MySQL的内部操作

![image-20201212150101150](/Users/xjf/IdeaProjects/theJava/mysql/gitee/pic/image-20201212150101150.png)



1、业务SQL执行过程，某个 RM 崩溃怎么处理？ 

没有到prepare状态，回滚

2、全部prepare后，某个 RM 崩溃怎么处理？ 

5.6之前的版本，如果网络波动，客户端和MySQL服务端断开，MySQL会把事务回滚，TM依旧会commit其他事务，造成数据不一致的问题

5.7之后的版本，客户端和MySQL服务端断开，重连后事务依旧是prepare状态，TM可以使其commit

3、commit时，某个 RM 崩溃怎么办？

重试，监控，人工干预



### XA协议存在的问题

**注意：XA默认不会改变隔离级别**

![image-20201212150336577](/Users/xjf/IdeaProjects/theJava/mysql/gitee/pic/image-20201212150336577.png)





## BASE柔性事务

如果将实现了 `ACID`的事务要素的事务称为刚性事务的话，那么基于 `BASE` 事务要素的事务则称 为柔性事务。 

BASE 是基本可用、柔性状态和最终一致性这三个要素的缩写。 

* 基本可用（Basically Available）保证分布式事务参与方不一定同时在线。
* 柔性状态（Soft state）则允许系统状态更新有一定的延时，这个延时对客户来说不一定能够察觉。 
* 最终一致性（Eventually consistent）通常是通过消息传递的方式保证系统的最终一致性。

在 ACID 事务中对隔离性的要求很高，在事务执行过程中，必须将所有的资源锁定。 柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。通过放宽对强一致性要求， 来换取系统吞吐量的提升

![image-20201212152359789](/Users/xjf/IdeaProjects/theJava/mysql/gitee/pic/image-20201212152359789.png)



### `TCC` 通过手动补偿处理 

TCC模式即将每个服务业务操作分为两个阶段，第一个阶段`检查并预留相关资源`，第二阶段根据所有服务业务的 `Try` 状态来操作，如果都成功，则进行 `Confirm` 操作，如果任意一个 `Try` 发生错误，则全部 `Cancel`。

 TCC使用要求就是`业务接口`都必须实现三段逻辑（三个小事务）： 

1. 准备操作 `Try`：完成所有业务检查，预留必须的业务资源。 
2. 确认操作 `Confirm`：真正执行的业务逻辑，不做任何业务检查，只使用 `Try` 阶段预留的业务资源。因此， 只要 `Try` 操作成功，`Confirm` 必须能成功(如果失败，重试或 `Cancel`)。另外，Confirm 操作需满足幂等性，保证一笔分布式事务能且只能成功一次。 
3. 取消操作 Cancel：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性

> TCC需要定义各个阶段的逻辑，对业务本身的设计有非常大的影响
>
> TCC不依赖于数据库是否支持分布式事务，通过对业务逻辑的分解实现分布式事务

<img src="/Users/xjf/IdeaProjects/theJava/mysql/gitee/pic/image-20201212155459736.png" alt="image-20201212155459736" style="zoom:50%;" />

TCC 需要注意的几个问题： 1、允许空回滚(try报错，cancel不执行或短路) 2、防悬挂控制（要保证cancel会在try之后执行） 3、幂等设计

### `AT` 通过自动补偿处理

AT 模式就是两阶段提交，自动生成反向SQL



> 柔性事务的本质：乐观锁
>
> XA：悲观锁

分布式事务是在异步的对不同数据库进行变更，XA可以做到读已提交，每个数据库串行化，柔性事务是读未提交，可能存在脏数据，需要合理设计业务，保证不同数据库信息之间没有依赖关系