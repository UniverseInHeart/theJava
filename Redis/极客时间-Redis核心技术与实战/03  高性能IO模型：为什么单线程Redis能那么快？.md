

[TOC]



Redis 是单线程，主要是指 Redis 的 **网络 IO** 和 **键值对读写** 是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

## Redis 为什么用单线程？(多线程的开销)

多线程编程模式面临的**共享资源的并发访问控制问题**



## 单线程 Redis 为什么那么快？

1. Redis 的大部分操作在 **内存** 上完成，再加上它采用了高效的数据结构，例如哈希表和跳表
2. Redis 采用了 **多路复用机制**，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率



## 基本 IO 模型与阻塞点

以 `Get` 请求为例，为了处理一个 `Get` 请求，需要监听客户端请求（`bind/listen`），和客户端建立连接（`accept`），从 `socket` 中读取请求（`recv`），解析客户端发送请求（`parse`），根据请求类型读取键值数据（`get`），最后给客户端返回结果，即向 `socket` 中写回数据（`send`）。

下图显示了这一过程，其中，`bind/listen`、`accept`、`recv`、`parse` 和 `send` 属于网络 IO 处理，而 `get` 属于键值数据操作。既然 Redis 是单线程，那么，最基本的一种实现是在一个线程中依次执行上面说的这些操作。

<img src="pic/image-20210110182324959.png" alt="image-20210110182324959" style="zoom:80%;" />



网络 IO 操作中，有潜在的阻塞点，分别是 `accept()` 和 `recv()`。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 `accept()` 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 `Redis` 通过 `recv()` 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 `recv()`。

这就导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。不过，幸运的是，**socket 网络模型本身支持非阻塞模式**



### 非阻塞模式

`Socket` 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上，如果想要使用 `socket` 非阻塞模式，就必须要了解这三个函数的调用返回类型和设置模式

在 `socket` 模型中，不同操作调用后会返回不同的套接字类型。`socket()` 方法会返回主动套接字，然后调用 `listen()` 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 `accept()` 方法接收到达的客户端连接，并返回已连接套接字。

<img src="pic/image-20210110185051995.png" alt="image-20210110185051995" style="zoom:80%;" />

针对**监听套接字**设置非阻塞模式：当 Redis 调用 `accept()` 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 `accept()` 时，已经存在监听套接字了。虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。

针对**已连接套接字**设置非阻塞模式：Redis 调用 `recv()` 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知 Redis。

这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。到此，Linux 中的 IO 多路复用机制就要登场了。



### 基于多路复用的高性能 I/O 模型

Linux 中的 IO 多路复用机制是指**一个线程处理多个 IO 流**，就是我们经常听到的 **select/epoll 机制**

在 Redis 只运行单线程的情况下，**该机制允许内核中，同时存在多个监听套接字和已连接套接字**。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

<img src="pic/image-20210110190900846.png" alt="image-20210110190900846" style="zoom:80%;" />

图中的多个 `FD` 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，`Redis` 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。

为了在请求到达时能通知到 Redis 线程，`select/epoll` 提供了**基于事件的回调机制**，即针对不同事件的发生，调用相应的处理函数。`select/epoll` 一旦监测到 `FD` 上有请求到达时，就会触发相应的事件。

这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。

方便理解，再以连接请求和读数据请求为例，具体解释一下。如两个请求分别对应 `Accept` 事件和 `Read` 事件，`Redis` 分别对这两个事件注册 `accept` 和 `get` 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 `Accept` 事件和 `Read` 事件，此时，内核就会回调 `Redis` 相应的 `accept` 和 `get` 函数进行处理。







