Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。

- 读操作：主库、从库都可以接收；
- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

<img src="pic/image-20210114224608756.png" alt="image-20210114224608756" style="zoom:50%;" />

### 主从库间如何进行第一次同步？

通过 `replicaof`（Redis 5.0 之前使用 `slaveof`）命令形成主库和从库的关系

<img src="pic/image-20210114224736883.png" alt="image-20210114224736883" style="zoom:80%;" />

**第一阶段：建立连接，协商同步**

从库给主库发送 `psync` 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。

`psync` 命令包含了 **主库的 `runID`** 和 **复制进度 `offset`** 两个参数。

- `runID`，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”
- `offset`，此时设为 -1，表示第一次复制。

主库收到 `psync` 命令后，会用 `FULLRESYNC` 响应命令带上两个参数：**主库 runID** 和 **主库目前的复制进度 offset**，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，**`FULLRESYNC` 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库**

**第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。**

具体来说，主库执行 `bgsave` 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先 **清空当前数据库**，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。

在主库将数据同步给从库的过程中，主库不会被阻塞，但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 `replication buffer`，**记录 RDB 文件生成后收到的所有写操作**。

**第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。**

具体的操作是，当主库完成 RDB 文件发送后，就会把此时 `replication buffer` 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。





### 主从级联模式分担全量复制时的主库压力

通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。

 <img src="pic/image-20210114225744977.png" alt="image-20210114225744977" style="zoom:70%;" />



一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为**基于长连接的命令传播**，可以避免频繁建立连接的开销。



### 主从库间网络断了怎么办？

在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。

从 Redis 2.8 开始，网络断了之后，主从库会采用 **增量复制** 的方式继续同步。全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。

>  增量复制时，主从库之间具体是怎么保持同步的呢？
>
> **repl_backlog_buffer 缓冲区**
>
> 当主从库断连后，主库会把断连期间收到的写操作命令，写入 `replication buffer`，同时也会把这些操作命令也写入 `repl_backlog_buffer`  这个缓冲区。
>
> `repl_backlog_buffer` 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。
>
> 刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是  `master_repl_offset`。主库接收的新写操作越多，这个值就会越大。同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。



<img src="pic/image-20210115232735345.png" alt="image-20210115232735345" style="zoom:80%;" />

> 主从库的连接恢复之后，从库首先会给主库发送  `psync` 命令，并把自己当前的 `slave_repl_offset` 发给主库，主库会判断自己的 `master_repl_offset` 和  `slave_repl_offset`  之间的差距。
>
> 在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，`master_repl_offset` 会大于  `slave_repl_offset`。此时，主库只用把 `master_repl_offset` 和 `slave_repl_offset`  之间的命令操作同步给从库就行。就像刚刚示意图的中间部分，主库和从库之间相差了 put d e 和 put d f  两个操作，在增量复制时，主库只需要把它们同步给从库，就行了。

<img src="pic/image-20210115232858938.png" alt="image-20210115232858938" style="zoom:80%;" />

因为 `repl_backlog_buffer` 是一个 **环形缓冲区**，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。**如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致**。可以调整 `repl_backlog_size`  这个参数。这个参数和所需的缓冲空间大小有关。

缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。

在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一到两倍

